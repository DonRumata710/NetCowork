/* Demonstrates Bison C++ complete interface see Bison 10.1.6.2 Complete Symbols */
/* Compile: reflex --flex --bison-complete --bison-locations flexexample11.lxx */
/* Compile: bison -d reflexexample11.yxx */

%require "3.2"

%language "c++"
%define api.namespace {yy}
%define api.parser.class {parser}
%define api.value.type variant
%define api.token.constructor

%define parse.error verbose

%defines

%locations
%define api.location.file "location.hpp"

%parse-param {const std::string& folder}
%parse-param {yy::scanner& lexer}
%parse-param {InterfaceModel& model}
%parse-param {std::vector<std::string>& errors}

%define api.token.prefix {TOK_}
%token
    INCLUDE "include"
    IMPORT  "import"
    CLASS   "class"
    GETTER  "get"
    SETTER  "set"
;
%token <std::string> STR "string";
%token <double> NUM "number";

%token '!' '#' '$' '%' '&' '(' ')' '*' '+' ',' '-' '.' '/' ':' ';' '<' '=' '>' '?' '[' ']' '^' '{' '|' '}' '~'

%token EOF 0 "End of file";

%nterm <Class*> class;
%nterm <DefinitionList> definition_list;
%nterm <Property> definition;
%nterm <std::pair<std::string, std::string>> getset;
%nterm <std::string> get;
%nterm <std::string> set;

%code requires {
    #include "interfacemodel.h"
    namespace yy {
        class scanner;
    };

    struct DefinitionList
    {
        std::vector<Property> properties;
    };
}

%code {
    #include "interface.lexer.hpp"  /* Generated by reflex. */
    #include <iostream>
    #include <fstream>
    #include <filesystem>
    #undef yylex
    #define yylex lexer.yylex  /* Within bison's parse() we should invoke lexer.yylex(), not the global yylex() */
}

%%

interface
    : file
    ;

file
    : file class
    | file import
    | file INCLUDE '"' STR '"'              {
                                                auto path = std::filesystem::current_path();
                                                std::filesystem::current_path(folder);

                                                std::string filename = $4;
                                                std::ifstream file(filename);

                                                std::string new_folder = std::filesystem::path(filename).parent_path().string();

                                                yy::scanner scanner(file, &std::cout);
                                                yy::parser parser(new_folder, scanner, model, errors);
                                                int res = parser.parse();

                                                std::filesystem::current_path(path);
                                                if (res)
                                                {
                                                    throw std::runtime_error("Parsing file '" + $4 + "' was failed with code " + std::to_string(res) + "\n");
                                                }
                                            }
    |
    ;

import
    : IMPORT STR STR ';'                    { model.add_dependency(Dependency{$3, $3, Type_from_str[$2]}); }
    | IMPORT STR STR '.' STR ';'            { model.add_dependency(Dependency{$3, $5, Type_from_str[$2]}); }
    ;

class
    : CLASS STR '{' definition_list '}' ';' {
                                                auto* cls = model.add_class(Class($2));
                                                cls->add_properties($4.properties);
                                            }
    ;

definition_list
    : definition_list definition            {
                                                $1.properties.push_back(std::move($2));
                                                $$ = std::move($1);
                                            }
    |                                       { $$ = {}; }
    ;

definition
    : STR STR '{' getset '}' ';'            {
                                                Parameter param;
                                                param.element = model.get_type($1);
                                                param.value_name = $2;
                                                $$.parameter = param;
                                                if ($4.first.empty())
                                                    $$.getter = "get_" + param.value_name;
                                                else
                                                    $$.getter = $4.first;
                                                if ($4.second.empty())
                                                    $$.setter = "set_" + param.value_name;
                                                else
                                                    $$.setter = $4.second;
                                            }

    | STR STR ';'                           {
                                                Parameter param;
                                                param.element = model.get_type($1);
                                                param.value_name = $2;
                                                $$.parameter = param;
                                                $$.getter = "get_" + param.value_name;
                                                $$.setter = "set_" + param.value_name;
                                            }
    ;

getset
    : get                                   { $$ = { $1, "" }; }
    | set                                   { $$ = { "", $1 }; }
    | get ',' set                           { $$ = { $1, $3 }; }
    | set ',' get                           { $$ = { $3, $1 }; }
    ;

set : SETTER ':' STR                        { $$ = $3; }
get : GETTER ':' STR                        { $$ = $3; }

%%

void yy::parser::error(const location& loc, const std::string& msg)
{
    throw std::runtime_error("Parsing error in line " + std::to_string(loc.begin.line) + ": " + msg);
}
